### 设计模式的学习
#### 简单工厂模式
自我理解: 通过不同type的类型生成不同的实例对象
比如: 各种小形状 通过工厂来对不同的type 生成形状的对象 颗粒度更小

#### 抽象工厂模式
自我理解: 对简单工厂的抽象，工厂的工厂, 把所有工厂收集起来生成一个工厂函数,然后根据type来选择创建哪个工厂函数
比如：形状的工厂 颜色的工厂  通过形状的type和颜色的type来生成对应的工厂(调用这个抽象工厂) 颗粒度大一点

#### 建造者模式
自我理解: 写颗粒度很细的对象，然后组合在一起，生成一个更复杂的对象，更加关心每一步的实现过程
比如: 汉堡+饮料 --> 香辣鸡翅+可乐 --> 套餐1

#### 原型模式 
自我理解1: 创建对象过程中，可以公用不咋变的方法和属性可以写在原型对象上来共享，因为是引用类型
实现方式: 通过call去复制基础类的属性，通过new去复制基础类的方法

自我理解2: 遇到构造函数constructor比较复杂 或者 耗时比较长 或者 需要通过多个对象拼凑出来的 不要用new 直接复制的方式
实现方式: 搞一个函数，把属性和方法全部复制到这个缓存函数的prototype上

自我理解3: 浅拷贝和深拷贝

#### 单例模式 
自我理解: 对象永远是那一个

#### 外观模式
自我理解: 懒的看三个接口的实现，只想知道怎么调用的就好了，自己写一个类，把几个接口调用 封装起来 用的时候就用你自己的这个类，这样就可以不用改之前的逻辑了
专业理解：隐藏内部的复杂性，这样能减少一些对内部修改的可能，同时对外暴露单一功能接口，也有利于降低复杂性

#### 适配器模式
自我理解: 适配器函数里面 根据type类型准备好适配的方法和属性, 使用的时候，直接用适配器类来生成一个要使用的类进行实例化
比如: 不管是ios还是android，准备好各自的方法，在适配器类上先生成好调用方法，在使用类上调用适配器，直接使用，完事

#### 代理模式
自我理解: 你在访问对象前可以拦截做一些事情 搞清楚Proxy和Reflect咋用的，代理模式使用过程中,
        对基础类进行代理的代理类还没有初始化的时候就初始化，初始化过了就直接使用
        能在不改变原有类的情况下，实现一些功能或者实现拦截和一些前置操作