### 设计模式的学习
#### 简单工厂模式
自我理解: 通过不同type的类型生成不同的实例对象
比如: 各种小形状 通过工厂来对不同的type 生成形状的对象 颗粒度更小

#### 抽象工厂模式
自我理解: 对简单工厂的抽象，工厂的工厂, 把所有工厂收集起来生成一个工厂函数,然后根据type来选择创建哪个工厂函数
比如：形状的工厂 颜色的工厂  通过形状的type和颜色的type来生成对应的工厂(调用这个抽象工厂) 颗粒度大一点

#### 建造者模式
自我理解: 写颗粒度很细的对象，然后组合在一起，生成一个更复杂的对象，更加关心每一步的实现过程
比如: 汉堡+饮料 --> 香辣鸡翅+可乐 --> 套餐1

#### 原型模式(难点)
自我理解1: 创建对象过程中，可以公用不咋变的方法和属性可以写在原型对象上来共享，因为是引用类型
实现方式: 通过call去复制基础类的属性，通过new去复制基础类的方法

自我理解2: 遇到构造函数constructor比较复杂 或者 耗时比较长 或者 需要通过多个对象拼凑出来的 不要用new 直接复制的方式
实现方式: 搞一个函数，把属性和方法全部复制到这个缓存函数的prototype上

自我理解3: 浅拷贝和深拷贝

#### 单例模式
自我理解: 对象永远是那一个

#### 外观模式
自我理解: 懒的看三个接口的实现，只想知道怎么调用的就好了，自己写一个类，把几个接口调用 封装起来 用的时候就用你自己的这个类，这样就可以不用改之前的逻辑了
专业理解：隐藏内部的复杂性，这样能减少一些对内部修改的可能，同时对外暴露单一功能接口，也有利于降低复杂性

#### 适配器模式(难点)
自我理解: 适配器函数里面 根据type类型准备好适配的方法和属性, 使用的时候，直接用适配器类来生成一个要使用的类进行实例化
比如: 不管是ios还是android，准备好各自的方法，在适配器类上先生成好调用方法，在使用类上调用适配器，直接使用，完事

#### 代理模式(难点)
自我理解: 你在访问对象前可以拦截做一些事情 搞清楚Proxy和Reflect咋用的，代理模式使用过程中,
        对基础类进行代理的代理类还没有初始化的时候就初始化，初始化过了就直接使用
        能在不改变原有类的情况下，实现一些功能或者实现拦截和一些前置操作

#### 装饰器模式
自我理解: 有点像高阶函数 class1(class2) --> 生成出class3,装饰过后的class3既有class2的东西也有class1新增的东西，就挺好

#### 桥接模式
自我理解：定义一个抽象层和实现层，然后实现层去继承这个抽象层，不管基础类的调用方法怎么变化，通过这个实现层可以很好的把对外调用的接口统一

#### 组合模式
自我理解: 准备一个数组，只需要关心自己下一级的状态，不需要关心上一级的状态，适合树形结构
专业理解：让相互关联的对象产生了结构性，无论是在关系修改或者是关系直观性上，都只需要关心当前下级的关系，
        那么这样能更好的降低关系和关系之间的复杂度，加强单对象关系结构的可维护性。

#### 享元模式
自我理解: 利用Map减少相同实例对象的创建,就是减少重复创建实例化的对象

#### 模板模式
自我理解: 父类里面定义好模板方法,不进行实现,子类去继承并实现里面的方法,但是执行方法写在父类上

#### 观察者模式(非常常用)
自我理解: 就是准备一个数组 每次调用都push进去 然后for循环遍历这个数组, 通知订阅的子类

#### 状态模式
自我理解: 在一个函数内定义一个对象 里面封装了一系列状态，然后通过对象的方式存储和遍历出来，每个调用者都有一个全量的状态对象

#### 策略模式
自我理解: 和状态模式很像，区别在于，策略模式更侧重 单个策略的调用 而不关心其他策略 等要用了再去调用 类似查字典

#### 职责链模式
自我理解: 大级别的套小级别的，使用的时候 用大级别的，小级别的自动输出
当前责任人只需要关心自己应该尽什么责任，而不是要关心，自己完成责任后而发什么的其它的什么责任。避免了发送者和多个接受者耦合在一起
